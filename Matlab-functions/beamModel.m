% Calculates the resonance frequencies for a beam conected to translational and% rotational springs in each end% clear variables% close all% clc%% ===========================================================================% setup% ============================================================================% Frequency vectorf = logspace(log10(1),log10(10000),1000);%Geometry, mh = 0.011;b = 0.046;L = 0.935;%Material properties (updated to match lab 5/6 beam)E   = 3.75e9;	% Pa, (originally 4.5e9 Pa)rho = 1150;	  % kg/m^3 (originally 1350 kg/m^3)eta = 0.069;%% ===========================================================================% some pre-processing% ============================================================================% Cross-sectional area and moment of inertia% rectangularS=b*h;I=b*h^3/12;% circular%S=(h/2).^2*pi;%I=pi*h^4/32;% Bending stiffnessB=E*(1+1j*eta)*I;% Springs at endss1 = 0; 		% left translations2 = 0;			% left rotations3 = 0;			% right translations4 = 0;			% right rotation% Only zeros means free-free conditions% Wavenumber vectork_vec = sqrt(2*pi*f).*(rho*S/B).^(1/4);% Load vector l, [1 0 0 0] = unit force at x=0l = [1 0 0 0]';%% ===========================================================================% assemble equation system matrix for each frequency/wavenumber and get% wave components% ============================================================================% For each wavenumber (i.e. frequency)for mm=length(k_vec):-1:1 % trick: looping backwards avoids need to preallocate an  % Pick out the corresponding wavenumber	k = k_vec(mm);	% Equation system matrix (see eq. (4.14), TA1)	M =	[ [	(B*1j*k.^3-s1) 				        -(B*1j*k.^3+s1) 			          -(B*k.^3+s1) 				       (B*k.^3-s1)			]		    [	(B*k.^2+s2*1j*k) 			         (B*k.^2-s2*1j*k) 			        -(B*k.^2-s2*k) 			      -(B*k.^2+s2*k)			]		    [	(B*1j*k.^3-s3)*exp(-1j*k*L) 	-(B*1j*k.^3+s3)*exp(1j*k*L) 	  -(B*k.^3+s3)*exp(-k*L) 	   (B*k.^3-s3)*exp(k*L)	]		    [	(B*k^2+s4*1j*k).*exp(-1j*k*L)  (B*k.^2-s4*1j*k).*exp(1j*k*L)  -(B*k.^2-s4*k).*exp(-k*L) -(B*k.^2+s4*k).*exp(k*L)	]];  % Solve the equation system for the amplitudes of the +- travelling propagating and evanscent waves  % NOTE: for high frequencies Matlab will throw a warning here: 'Matrix is close to singular or badly scaled. Results may be inaccurate.'  % Numerically this means that there is a too big difference between the smallest  % and the largest entries in M. In this particular case, these are the entries  % in M(3:4,3:4) with the exp(+-k*L) terms for the nearfield componets which get  % extremely small (exp(-kL)) and extremely big (exp(kL)) for large values of  % k. Since this is just a warning things might still be ok, you can check the  % accuracy of your results by using obtained solution an(:,mm) to re-calculate  % the known b: M*an(:,mm)-b should be close to zero.  % Physically this warning can be seen as a sign that you are starting to reach  % frequency regions where the simple Euler-Bernoulli theory maybe no longer applies.	an(:,mm) = M\l;end%% ===========================================================================% calulcate total displacement and mobility% ============================================================================% Total displacement evaluated at x=0xsi = an(1,:) + an(2,:) + an(3,:) + an(4,:); % xsi=sum(an,1); shorter but less pedagocial% Mobility, /1 for force = 1 NY = 1j*2*pi*f.*xsi/1;%% ===========================================================================% plot results% ============================================================================figure(1)semilogx(f,20*log10(abs(Y)),'k-','LineWidth',3)axis([1 1000 -45 0])set(gca,'FontName','Times')set(gca,'FontSize',16)legend('Modelled')xlabel('frequency in Hz')ylabel('Mobility in dB re. 1 m/Ns')